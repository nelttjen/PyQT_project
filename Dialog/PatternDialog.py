# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'DialogPattern.ui'
#
# Created by: PyQt5 UI code generator 5.15.5
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import os.path
import shutil

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt, QSize
from PIL import Image
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QPushButton, QColorDialog


from Dialog.AgreementDialog import AgreementDialog
from Dialog.ChangeDialog import ChangeDialog
from Pattern.Pattern import find_pattern_by_id
from Pattern.RegPatterns import recreate_patterns
from Utils.ChangeCSV import change_color, restore_default_csv
from Utils.DatabaseHandler import change_to_db, remove_pattern_from_db
from Utils.ImageSelect import image_select
from Utils.Pallite import create_palette
from Utils.Path import *
from Utils.StyleSheet import add_style_sheet

from Utils.Values import CREATE, CHANGE, CHANGE_DEFAULT, DEFAULT_PATTERNS_COUNT, NEW_PATTERN_PATH


def copy_new_pattern(pattern_id):
    pattern_name = f'pattern{int(pattern_id)}.png'
    path = './Images/Patterns/' + pattern_name
    preview_path = f'./Images/Patterns/Preview/' + pattern_name
    preview = Image.open(NEW_PATTERN_PATH)
    preview = preview.resize((284, 190))

    preview.save(preview_path)
    shutil.copy2(NEW_PATTERN_PATH, path)

    os.remove(NEW_PATTERN_PATH)


# Лейбл для регистраций кликов по нему
class QClickLabel(QtWidgets.QLabel):
    single_clicked = QtCore.pyqtSignal()
    double_clicked = QtCore.pyqtSignal()

    def mousePressEvent(self, event):
        self.single_clicked.emit()

    def mouseDoubleClickEvent(self, event):
        self.double_clicked.emit()


class PatternDialog(QtWidgets.QDialog):
    def __init__(self, parent=None, pattern_list=None):
        super(PatternDialog, self).__init__(parent, Qt.WindowCloseButtonHint)
        self.setObjectName("PatternDialog")
        self.setWindowTitle('Выбор шаблона')
        self.setFixedSize(923, 750)

        # default
        self.returnVal = None
        self.pattern_list = pattern_list
        self.viewed_patterns = []
        self.selected = None

        # buttons
        self.btn_select = None
        self.btn_change = None
        self.btn_create = None
        self.btn_delete = None
        self.reg_buttons()

        # color buttons
        self.color = None
        self.color_restore = None
        self.reg_color_buttons()

        # css Button style
        add_style_sheet([self.btn_select, self.btn_create, self.btn_change,
                         self.color, self.color_restore])

        # Создание Grid поля для отображения
        self.scrollArea = QtWidgets.QScrollArea(self)
        self.scrollArea.setWidgetResizable(True)
        self.scrollAreaWidgetContents = QtWidgets.QWidget()

        self.view_patterns = QtWidgets.QGridLayout(self.scrollAreaWidgetContents)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.scrollArea.setGeometry(QtCore.QRect(0, 0, 923, 590))

        # По 3 изображения на строке
        self.view_patterns.setColumnMinimumWidth(2, 0)

        # Изменение бекграунд цвета
        self.change_palette(self.objectName())

        # Добавление превью картинок в Grid поле
        self.reg_pattern_view()

    def reg_buttons(self):
        # базовое значение по x от края приложения, сделал для удобства
        base = 293

        # Регисрация основных кнопок
        self.btn_select = QtWidgets.QPushButton(self)
        self.btn_select.resize(100, 50)
        self.btn_select.clicked.connect(self.select_click)
        self.btn_select.setText('Выбрать')
        self.btn_select.move(base, 675)

        self.btn_change = QtWidgets.QPushButton(self)
        self.btn_change.resize(100, 50)
        self.btn_change.clicked.connect(self.change_click)
        self.btn_change.setText('Изменить')
        self.btn_change.move(base + 106, 675)

        self.btn_create = QtWidgets.QPushButton(self)
        self.btn_create.resize(100, 50)
        self.btn_create.clicked.connect(self.create_click)
        self.btn_create.setText('Создать')
        self.btn_create.move(base + 212, 675)

        self.btn_delete = QtWidgets.QPushButton(self)
        self.btn_delete.resize(40, 40)
        self.btn_delete.clicked.connect(self.delete_click)
        self.btn_delete.move(883, 710)
        delete_icon = QIcon('./Images/Default/trashcan.jpg')
        self.btn_delete.setIcon(delete_icon)
        self.btn_delete.setIconSize(QSize(34, 34))

    def reg_color_buttons(self):
        # Регистрация кнопок для цвета бекграунда
        self.color = QPushButton(self)
        self.color.resize(30, 30)
        self.color.move(0, 720)
        self.color.clicked.connect(self.change_color)
        color_icon = QIcon('./Images/Default/palette.png')
        self.color.setIcon(color_icon)

        self.color_restore = QPushButton(self)
        self.color_restore.resize(30, 30)
        self.color_restore.move(29, 720)
        self.color_restore.setText('D')
        self.color_restore.clicked.connect(self.default_color)

    def reg_pattern_view(self):
        # рег картинок
        for j in range(500 + DEFAULT_PATTERNS_COUNT):
            if j < len(self.pattern_list):
                x = j // 3
                y = j % 3
                cur_pattern = self.pattern_list[j].get_object()
                if not self.add_widget(cur_pattern, x, y):
                    # если вернуло что какая-то кастом картинка удалена - прервать
                    break
            else:
                break

    def clear_pattern_view(self):
        # удалить все существующие виджеты и очистить их
        for i in self.viewed_patterns:
            self.view_patterns.removeWidget(i[0])
        self.viewed_patterns = []

    def update_pattern_view(self):
        # Удалить и заного зарегать все картинки
        self.clear_pattern_view()
        self.reg_pattern_view()

    def add_widget(self, pattern, x, y):
        # Добавление картинки в Grid полы
        p_name = get_name_from_path(pattern[0])
        if p_name:
            preview_path = f'./Images/Patterns/Preview/{p_name}.png'
            pattern_path = f'./Images/Patterns/{p_name}.png'
            if os.path.exists(preview_path) and os.path.exists(pattern_path):
                pixmap = QtGui.QPixmap(preview_path)
                label = QClickLabel()
                label.setPixmap(pixmap)
                label.setObjectName(p_name)
                label.single_clicked.connect(self.select)
                label.double_clicked.connect(self.double_click)
                self.view_patterns.addWidget(label, x, y)
                self.viewed_patterns.append([label, preview_path, p_name])
                return True
            elif int(get_clean_id(p_name)) > DEFAULT_PATTERNS_COUNT:
                # На случай если кастом картинку удалили - удалить данные с бд
                self.delete_script(get_clean_id(p_name))
                # И опять зарегать все картинки сначала
                self.update_pattern_view()
                return False
            # Ну если удалили дефолт картинку - тут уже ниче не поделаешь, переустанавливайте :p
            return True

    def select(self):
        # Также вызывается при сингл клике по лейблу
        try:
            # записываем последнюю выбранную картинку
            last = self.selected
            # записываем новый id картинки
            p_name = self.sender().objectName()
            if not p_name:
                # если было получено с изменения или создания -
                # оставить селект на прошлой картинке
                p_name = last
            if last:
                # сетнуть ласт картинке норм вид
                self.update_picture(int(last.replace('pattern', '')))
            # создать и сохранить картинку с рамкой
            if p_name:
                # проверка, был ли вообще выбор
                image_select(p_name)
                pixmap = QtGui.QPixmap('./Images/Temp/select.png')
                if self.sender().objectName():
                    # если картинка не была получена с изменения или создания
                    self.sender().setPixmap(pixmap)
                else:
                    # иначе найти лейбл по имени и изменить картинку
                    self.find_label_by_name(p_name).setPixmap(pixmap)
                # ну и записать pattern_name как селект
                self.selected = p_name
        except FileNotFoundError as e:
            # вдруг preview файл был удален
            self.error_message(e.__str__())
        except AttributeError as e:
            self.error_message(e.__str__())

    def update_picture(self, pattern_id):
        # поиск и восстановление картинки нужного лейбла, id = чистый
        for i in self.viewed_patterns:
            if get_clean_id(i[2]) == str(pattern_id):
                path = f'./Images/Patterns/Preview/pattern{pattern_id}.png'
                pixmap = QtGui.QPixmap(path)
                i[0].setPixmap(pixmap)
                break

    def find_label_by_name(self, pattern_name):
        # поиск лейбла по имени, имя - pattern_name
        for i in self.viewed_patterns:
            if i[2] == pattern_name:
                return i[0]

    def double_click(self):
        # Действие при дабл клике по лейблу
        for i in self.viewed_patterns:
            if self.sender() == i[0]:
                self.returnVal = i[1]
                self.accept()

    def select_click(self):
        # кнопка выбрать
        if self.selected:
            self.returnVal = self.selected
            self.accept()
        else:
            # шаблон не выбран
            self.error_message()

    def change_click(self):
        # кнопка изменить
        if self.selected:
            # найти иизменяемый шаблон
            pattern = find_pattern_by_id(self.pattern_list, self.selected)
            mode = CHANGE_DEFAULT if pattern[5] else CHANGE
            # если дефолт - картинки не изменяется
            # поэтому открываем только есть у дефолта есть текст
            if mode == CHANGE or (mode == CHANGE_DEFAULT and (pattern[1][0] or pattern[2][0])):
                new_list, has_changes, has_img_changes = ChangeDialog(self, pattern=pattern, mode=mode).exec_()
            else:
                # если выбранный шаблон = дефолтный и только с картинками
                self.error_message("Этот шаблон изменить нельзя")
                return
            if has_changes:
                # если окошко не закрыли просто так
                change_to_db(new_list)
                # обновить шаблоны с новыми данными
                self.pattern_list = recreate_patterns()
            if has_img_changes:
                # если меняли картинку
                pattern_id = int(get_clean_id(pattern[0]))
                # скопировать её и опять выбрать
                copy_new_pattern(pattern_id)
                self.select()
        else:
            # не выбран шаблон
            self.error_message()

    def create_click(self):
        new_list, has_changes, has_img_changes = ChangeDialog(self, mode=CREATE).exec_()
        # если окно не закрыли
        if has_changes:
            # проверка, не удалили ли новый шаблон с темп папки
            if os.path.exists(NEW_PATTERN_PATH):
                # скрипт создания шаблона
                change_to_db(new_list)
                copy_new_pattern(new_list[6] + DEFAULT_PATTERNS_COUNT)
                # ну и обновление всех данных в окне
                self.pattern_list = recreate_patterns()
                self.update_pattern_view()
                self.select()
            else:
                # new_pattern.png был удален
                self.error_message('При создании шаблона что-то пошло не так')

    def delete_click(self):
        # кнопка удалить
        if not self.selected:
            self.error_message()
            return
        pattern = find_pattern_by_id(self.pattern_list, self.selected)
        if pattern:
            if pattern[5]:
                # если дефолт шаблон
                self.error_message('Этот шаблон является базовым и не может быть удалён')
                return
            else:
                # спрашиваем дополнительное подтверждение
                agreement = AgreementDialog(self,
                                            'Вы действительно хотите\n удалить этот шаблон?').exec_()
                if agreement:
                    # если согласны - удалить
                    self.delete_script(get_clean_id(pattern[0]))

    def delete_script(self, pattern_id):
        # удаляем с бд
        remove_pattern_from_db(pattern_id)

        # удаляем картинки
        path1 = f'./Images/Patterns/pattern{pattern_id}.png'
        path2 = f'./Images/Patterns/Preview/pattern{pattern_id}.png'
        os.remove(path1) if os.path.exists(path1) else None
        os.remove(path2) if os.path.exists(path2) else None

        # обновляем данные
        self.pattern_list = recreate_patterns()
        self.update_pattern_view()
        self.selected = None

    # 2 кнопки с цветом
    def change_color(self):
        color = QColorDialog.getColor()
        if color.isValid():
            self.set_color(color)

    def set_color(self, color):
        key_id = self.objectName()
        change_color(color, key_id)
        self.change_palette(key_id)

    def default_color(self):
        sure = AgreementDialog(self, 'Вы действительно хотите\nвостановить значение по умолчанию?').exec_()
        if sure:
            key_id = self.objectName()
            restore_default_csv(key_id=key_id, is_full_restore=False)
            self.change_palette(key_id)

    # изменение бекграунда
    def change_palette(self, key_id):
        new_palette = create_palette(key_id)
        self.scrollArea.setPalette(new_palette)
        self.scrollAreaWidgetContents.setPalette(new_palette)
        self.setPalette(new_palette)

    def error_message(self, msg="Не выбран шаблон"):
        # чтоб кучу раз не выззывать message box
        QtWidgets.QMessageBox.critical(self, "Ошибка ", msg, QtWidgets.QMessageBox.Ok)

    # возвращение значений с окна
    def exec_(self):
        super(PatternDialog, self).exec_()
        return self.returnVal, self.pattern_list
